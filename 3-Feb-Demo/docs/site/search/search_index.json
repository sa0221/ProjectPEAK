{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"collector/","text":"Collector Documentation Collector Service Module for Project PEAK This module implements an asynchronous signal collection service designed for distributed RF data gathering. It supports multiple hardware interfaces (Bluetooth, ADS-B via RTL-SDR, and Wi-Fi) to scan, capture, and process electromagnetic signals from various sources, then forward the collected data to a centralized Controller API for further analysis and storage. Key Features Asynchronous scanning for high-performance, non-blocking operation. Dynamic hardware detection: verifies presence of HackRF, RTL-SDR dongle, Bluetooth adapter, and Wi-Fi interfaces. Concurrent execution of multiple scanning routines with robust error handling. Automatic packaging of captured signals with metadata (timestamp, type, signal strength, etc.). Reliable communication with the Controller API for device registration and signal data posting. Environment Variables CONTROLLER_URL (str): The base URL for the Controller API (default: \"http://controller:8000\"). SCAN_INTERVAL (int): Interval in seconds between successive scanning cycles. COLLECTION_TIMEOUT (int): Timeout in seconds for each scanning operation. Usage This module should be executed directly. It enters an infinite asynchronous loop, constantly checking if collection is active and then performing available hardware scans accordingly. Author: [Your Name] Date: 2025-04-14 capture_adsb () async Capture ADS-B signals using the dump1090-mutability tool. This method spawns a subprocess to execute dump1090-mutability in interactive mode, capturing real-time output from an RTL-SDR dongle. The scan runs for up to COLLECTION_TIMEOUT seconds. For each line that begins with an asterisk (\"*\"), indicating an ADS-B message, a dictionary with the following keys is created: - Timestamp: Capture time in ISO format. - Type: \"ADS-B\" to denote the kind of signal. - Name/Address: Uses a hardcoded \"Aircraft\" identifier. - Signal Strength: \"N/A\" as a placeholder because actual RSSI measurement is not performed. - Frequency: \"1090 MHz\" representing ADS-B frequency. - Additional Info: Raw data (decoded message line). - Latitude/Longitude: Remain as None pending integration of geolocation. Returns: Type Description list [ dict ] list[dict]: List of dictionaries with ADS-B signal data. Error Handling All subprocess exceptions are captured, and an empty list is returned in case of failure. Note An operational RTL-SDR dongle is a prerequisite for this function to yield useful data. Source code in 3-Feb-Demo/collector.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def capture_adsb () -> list [ dict ]: \"\"\" Capture ADS-B signals using the dump1090-mutability tool. This method spawns a subprocess to execute dump1090-mutability in interactive mode, capturing real-time output from an RTL-SDR dongle. The scan runs for up to COLLECTION_TIMEOUT seconds. For each line that begins with an asterisk (\"*\"), indicating an ADS-B message, a dictionary with the following keys is created: - Timestamp: Capture time in ISO format. - Type: \"ADS-B\" to denote the kind of signal. - Name/Address: Uses a hardcoded \"Aircraft\" identifier. - Signal Strength: \"N/A\" as a placeholder because actual RSSI measurement is not performed. - Frequency: \"1090 MHz\" representing ADS-B frequency. - Additional Info: Raw data (decoded message line). - Latitude/Longitude: Remain as None pending integration of geolocation. Returns: list[dict]: List of dictionaries with ADS-B signal data. Error Handling: All subprocess exceptions are captured, and an empty list is returned in case of failure. Note: An operational RTL-SDR dongle is a prerequisite for this function to yield useful data. \"\"\" try : proc = await asyncio . create_subprocess_exec ( \"dump1090-mutability\" , \"--interactive\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) signals : list [ dict ] = [] start_time = time . time () while time . time () - start_time < COLLECTION_TIMEOUT : line = await proc . stdout . readline () if line : decoded = line . decode () . strip () if decoded . startswith ( \"*\" ): signals . append ({ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"ADS-B\" , \"name_address\" : \"Aircraft\" , \"signal_strength\" : \"N/A\" , \"frequency\" : \"1090 MHz\" , \"additional_info\" : decoded , \"latitude\" : None , \"longitude\" : None }) proc . terminate () return signals except Exception as e : print ( f \"ADS-B error: { str ( e ) } \" ) return [] capture_wifi () async Perform a Wi-Fi scan by capturing probe requests through tcpdump. The function first determines an active wireless interface: it defaults to \"wlan0\" but will dynamically select another interface that exposes wireless capabilities if needed. It then spawns a subprocess to execute tcpdump with parameters to capture 10 packets (-c 10) in non-parsed format. The scanned output is parsed line-by-line to create a list of dictionaries with: - Timestamp: ISO-formatted time of capture. - Type: \"Wi-Fi\" indicating this scan type. - Name/Address: Descriptive label \"Probe Request\". - Signal Strength: Set as \"N/A\" (placeholder). - Frequency: \"2.4/5 GHz\" indicating the common operating bands. - Additional Info: The raw tcpdump output line. - Latitude/Longitude: Remain None for future enhancement. Returns: Type Description list [ dict ] list[dict]: List of detected Wi-Fi signals as dictionaries. Exception Handling If the subprocess fails or no wireless interface is found, logs the error and returns an empty list. Source code in 3-Feb-Demo/collector.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 async def capture_wifi () -> list [ dict ]: \"\"\" Perform a Wi-Fi scan by capturing probe requests through tcpdump. The function first determines an active wireless interface: it defaults to \"wlan0\" but will dynamically select another interface that exposes wireless capabilities if needed. It then spawns a subprocess to execute tcpdump with parameters to capture 10 packets (-c 10) in non-parsed format. The scanned output is parsed line-by-line to create a list of dictionaries with: - Timestamp: ISO-formatted time of capture. - Type: \"Wi-Fi\" indicating this scan type. - Name/Address: Descriptive label \"Probe Request\". - Signal Strength: Set as \"N/A\" (placeholder). - Frequency: \"2.4/5 GHz\" indicating the common operating bands. - Additional Info: The raw tcpdump output line. - Latitude/Longitude: Remain None for future enhancement. Returns: list[dict]: List of detected Wi-Fi signals as dictionaries. Exception Handling: If the subprocess fails or no wireless interface is found, logs the error and returns an empty list. \"\"\" interface : str = \"wlan0\" try : if not os . path . exists ( f \"/sys/class/net/ { interface } \" ): interfaces = os . listdir ( \"/sys/class/net\" ) interface = next (( i for i in interfaces if os . path . exists ( f \"/sys/class/net/ { i } /wireless\" )), \"eth0\" ) proc = await asyncio . create_subprocess_exec ( \"tcpdump\" , \"-i\" , interface , \"-c\" , \"10\" , \"-nn\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) output , _ = await proc . communicate () return [{ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"Wi-Fi\" , \"name_address\" : \"Probe Request\" , \"signal_strength\" : \"N/A\" , \"frequency\" : \"2.4/5 GHz\" , \"additional_info\" : line . strip (), \"latitude\" : None , \"longitude\" : None } for line in output . decode () . splitlines () if line . strip ()] except Exception as e : print ( f \"Wi-Fi scan error: { str ( e ) } \" ) return [] collect_and_send () async Main orchestration routine for dynamic hardware detection, signal collection, and communication with the Controller API. Operational Steps Hardware Detection : Checks for the presence of HackRF (for SDR), RTL-SDR dongles (for ADS-B), Bluetooth adapters (via 'hciconfig') and wireless interfaces. The results are compiled into a human-readable device list. Device Registration : Posts the detected devices list to the Controller at the '/api/devices' endpoint. If posting fails, it retries until successful. Signal Collection Loop : Periodically checks the Controller's collection status (via '/api/collection-status'). If active, concurrently dispatches available scan routines (Bluetooth, ADS-B, Wi-Fi). Aggregates all scan results, then sends the collection to the Controller's '/api/collect' endpoint. Waits for SCAN_INTERVAL seconds before starting the next cycle. Exception Handling Individual scan methods handle errors and return empty results on failure. The overall loop logs failures without breaking, ensuring continuous operation. Returns: Name Type Description None None The function perpetually runs in an asynchronous event loop. Design Consideration Uses asyncio.gather to perform scanning concurrently. This design optimizes resource usage while ensuring that hardware detection is adaptive and robust. Source code in 3-Feb-Demo/collector.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 async def collect_and_send () -> None : \"\"\" Main orchestration routine for dynamic hardware detection, signal collection, and communication with the Controller API. Operational Steps: 1. **Hardware Detection**: - Checks for the presence of HackRF (for SDR), RTL-SDR dongles (for ADS-B), Bluetooth adapters (via 'hciconfig') and wireless interfaces. - The results are compiled into a human-readable device list. 2. **Device Registration**: - Posts the detected devices list to the Controller at the '/api/devices' endpoint. - If posting fails, it retries until successful. 3. **Signal Collection Loop**: - Periodically checks the Controller's collection status (via '/api/collection-status'). - If active, concurrently dispatches available scan routines (Bluetooth, ADS-B, Wi-Fi). - Aggregates all scan results, then sends the collection to the Controller's '/api/collect' endpoint. - Waits for SCAN_INTERVAL seconds before starting the next cycle. Exception Handling: - Individual scan methods handle errors and return empty results on failure. - The overall loop logs failures without breaking, ensuring continuous operation. Returns: None: The function perpetually runs in an asynchronous event loop. Design Consideration: - Uses asyncio.gather to perform scanning concurrently. This design optimizes resource usage while ensuring that hardware detection is adaptive and robust. \"\"\" devices_posted : bool = False hackrf_present : bool = False rtlsdr_present : bool = False bt_present : bool = False wifi_ifaces : list [ str ] = [] # Check for HackRF One device (SDR) try : proc = await asyncio . create_subprocess_exec ( \"hackrf_info\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) await proc . communicate () if proc . returncode == 0 : hackrf_present = True except FileNotFoundError : pass # Check for RTL-SDR dongle (required for ADS-B) try : proc = await asyncio . create_subprocess_exec ( \"rtl_test\" , \"-t\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) await proc . communicate () if proc . returncode == 0 : rtlsdr_present = True except FileNotFoundError : pass # Check for Bluetooth adapter via hciconfig output. proc = await asyncio . create_subprocess_exec ( \"hciconfig\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) stdout , _ = await proc . communicate () if b \"hci0\" in stdout : bt_present = True # Detect available Wi-Fi interfaces based on the presence of 'wireless' directories. try : wifi_ifaces = [ iface for iface in os . listdir ( \"/sys/class/net\" ) if os . path . exists ( f \"/sys/class/net/ { iface } /wireless\" )] except Exception : wifi_ifaces = [] # Create a descriptive device list. device_list : list [ str ] = [] if hackrf_present : device_list . append ( \"HackRF One\" ) if rtlsdr_present : device_list . append ( \"RTL-SDR dongle\" ) if wifi_ifaces : device_list . append ( f \"Wi-Fi ( { ', ' . join ( wifi_ifaces ) } )\" ) if bt_present : device_list . append ( \"Bluetooth adapter\" ) if not device_list : device_list . append ( \"No RF devices detected\" ) # Register detected devices with the Controller API. try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/devices\" , json = { \"devices\" : device_list }) print ( f \"[Collector] Detected devices: { ', ' . join ( device_list ) } \" ) devices_posted = True except Exception as e : print ( f \"[Collector] Device info post failed: { e } \" ) devices_posted = False # Main asynchronous loop for repetitive scanning and signal reporting. while True : # Retry device registration if necessary. if not devices_posted : try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/devices\" , json = { \"devices\" : device_list }) print ( f \"[Collector] Detected devices: { ', ' . join ( device_list ) } \" ) devices_posted = True except Exception as e : print ( f \"[Collector] Retry device post: { e } \" ) # Proceed with scanning only if collection is enabled by the Controller. if await get_collection_status (): print ( \"[Collector] Starting collection cycle...\" ) tasks : list [ asyncio . Task ] = [] if bt_present : tasks . append ( asyncio . create_task ( scan_bluetooth ())) if rtlsdr_present : tasks . append ( asyncio . create_task ( capture_adsb ())) if wifi_ifaces : tasks . append ( asyncio . create_task ( capture_wifi ())) results = await asyncio . gather ( * tasks ) if tasks else [] all_signals = [ signal for sublist in results for signal in sublist ] # Send aggregated signals to Controller API if any have been collected. if all_signals : try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/collect\" , json = all_signals , timeout = 10 ) print ( f \"[Collector] Sent { len ( all_signals ) } signals\" ) except Exception as e : print ( f \"Failed to send data: { str ( e ) } \" ) else : print ( \"[Collector] No signals collected\" ) # Wait before beginning the next cycle. await asyncio . sleep ( SCAN_INTERVAL ) get_collection_status () async Retrieve and report whether the centralized Controller has activated data collection. The function makes an asynchronous GET request to the '/api/collection-status' endpoint on the Controller. In the case of errors (e.g., network issues or unexpected responses), it logs the error and returns False, thereby ensuring the collector does not scan unless the controller explicitly indicates active collection. Returns: Name Type Description bool bool True if the Controller API signals that signal collection is active, else False. Design Note This check is performed periodically before each scan cycle to conserve resources. Source code in 3-Feb-Demo/collector.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 async def get_collection_status () -> bool : \"\"\" Retrieve and report whether the centralized Controller has activated data collection. The function makes an asynchronous GET request to the '/api/collection-status' endpoint on the Controller. In the case of errors (e.g., network issues or unexpected responses), it logs the error and returns False, thereby ensuring the collector does not scan unless the controller explicitly indicates active collection. Returns: bool: True if the Controller API signals that signal collection is active, else False. Raises: Exception details are printed to standard output for debugging purposes. Design Note: This check is performed periodically before each scan cycle to conserve resources. \"\"\" try : async with httpx . AsyncClient () as client : response = await client . get ( f \" { CONTROLLER_URL } /api/collection-status\" ) return response . json () . get ( \"active\" , False ) except Exception as e : print ( f \"Error getting collection status: { e } \" ) return False main () Entry point for the Collector service module. Invokes the asynchronous collect_and_send() routine using asyncio.run(), initiating the perpetual scanning loop. Returns: Type Description None None Source code in 3-Feb-Demo/collector.py 334 335 336 337 338 339 340 341 342 343 def main () -> None : \"\"\" Entry point for the Collector service module. Invokes the asynchronous collect_and_send() routine using asyncio.run(), initiating the perpetual scanning loop. Returns: None \"\"\" asyncio . run ( collect_and_send ()) scan_bluetooth () async Conduct a Bluetooth Low Energy (BLE) scan for nearby devices using the Bleak library. This function leverages BleakScanner.discover to detect BLE devices for up to COLLECTION_TIMEOUT seconds. For every device found, it returns a dictionary with: - Timestamp: When the device was detected (ISO format). - Type: \"Bluetooth\" (identifies the scan type). - Name/Address: Combines the device name (if available) with its hardware address. - Signal Strength: Hardcoded placeholder (-70 dBm) pending future enhancement. - Frequency: \"2.4 GHz\" to denote typical BLE operation frequency. - Latitude/Longitude: Set as None (reserved for future geo-tagging). Returns: Type Description list [ dict ] list[dict]: A list of dictionaries, each representing an individual BLE device detection. Exception Handling Any scanning error is caught, logged, and the function returns an empty list. Future Enhancement Signal strength measurement may be refined to capture actual RSSI values dynamically. Source code in 3-Feb-Demo/collector.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def scan_bluetooth () -> list [ dict ]: \"\"\" Conduct a Bluetooth Low Energy (BLE) scan for nearby devices using the Bleak library. This function leverages BleakScanner.discover to detect BLE devices for up to COLLECTION_TIMEOUT seconds. For every device found, it returns a dictionary with: - Timestamp: When the device was detected (ISO format). - Type: \"Bluetooth\" (identifies the scan type). - Name/Address: Combines the device name (if available) with its hardware address. - Signal Strength: Hardcoded placeholder (-70 dBm) pending future enhancement. - Frequency: \"2.4 GHz\" to denote typical BLE operation frequency. - Latitude/Longitude: Set as None (reserved for future geo-tagging). Returns: list[dict]: A list of dictionaries, each representing an individual BLE device detection. Exception Handling: Any scanning error is caught, logged, and the function returns an empty list. Future Enhancement: Signal strength measurement may be refined to capture actual RSSI values dynamically. \"\"\" try : devices = await BleakScanner . discover ( timeout = COLLECTION_TIMEOUT ) return [{ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"Bluetooth\" , \"name_address\" : f \" { d . name or 'Unknown' } [ { d . address } ]\" , \"signal_strength\" : - 70 , \"frequency\" : \"2.4 GHz\" , \"latitude\" : None , \"longitude\" : None } for d in devices ] except Exception as e : print ( f \"Bluetooth scan error: { str ( e ) } \" ) return []","title":"Collector"},{"location":"collector/#collector-documentation","text":"Collector Service Module for Project PEAK This module implements an asynchronous signal collection service designed for distributed RF data gathering. It supports multiple hardware interfaces (Bluetooth, ADS-B via RTL-SDR, and Wi-Fi) to scan, capture, and process electromagnetic signals from various sources, then forward the collected data to a centralized Controller API for further analysis and storage. Key Features Asynchronous scanning for high-performance, non-blocking operation. Dynamic hardware detection: verifies presence of HackRF, RTL-SDR dongle, Bluetooth adapter, and Wi-Fi interfaces. Concurrent execution of multiple scanning routines with robust error handling. Automatic packaging of captured signals with metadata (timestamp, type, signal strength, etc.). Reliable communication with the Controller API for device registration and signal data posting. Environment Variables CONTROLLER_URL (str): The base URL for the Controller API (default: \"http://controller:8000\"). SCAN_INTERVAL (int): Interval in seconds between successive scanning cycles. COLLECTION_TIMEOUT (int): Timeout in seconds for each scanning operation. Usage This module should be executed directly. It enters an infinite asynchronous loop, constantly checking if collection is active and then performing available hardware scans accordingly. Author: [Your Name] Date: 2025-04-14","title":"Collector Documentation"},{"location":"collector/#collector.capture_adsb","text":"Capture ADS-B signals using the dump1090-mutability tool. This method spawns a subprocess to execute dump1090-mutability in interactive mode, capturing real-time output from an RTL-SDR dongle. The scan runs for up to COLLECTION_TIMEOUT seconds. For each line that begins with an asterisk (\"*\"), indicating an ADS-B message, a dictionary with the following keys is created: - Timestamp: Capture time in ISO format. - Type: \"ADS-B\" to denote the kind of signal. - Name/Address: Uses a hardcoded \"Aircraft\" identifier. - Signal Strength: \"N/A\" as a placeholder because actual RSSI measurement is not performed. - Frequency: \"1090 MHz\" representing ADS-B frequency. - Additional Info: Raw data (decoded message line). - Latitude/Longitude: Remain as None pending integration of geolocation. Returns: Type Description list [ dict ] list[dict]: List of dictionaries with ADS-B signal data. Error Handling All subprocess exceptions are captured, and an empty list is returned in case of failure. Note An operational RTL-SDR dongle is a prerequisite for this function to yield useful data. Source code in 3-Feb-Demo/collector.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 async def capture_adsb () -> list [ dict ]: \"\"\" Capture ADS-B signals using the dump1090-mutability tool. This method spawns a subprocess to execute dump1090-mutability in interactive mode, capturing real-time output from an RTL-SDR dongle. The scan runs for up to COLLECTION_TIMEOUT seconds. For each line that begins with an asterisk (\"*\"), indicating an ADS-B message, a dictionary with the following keys is created: - Timestamp: Capture time in ISO format. - Type: \"ADS-B\" to denote the kind of signal. - Name/Address: Uses a hardcoded \"Aircraft\" identifier. - Signal Strength: \"N/A\" as a placeholder because actual RSSI measurement is not performed. - Frequency: \"1090 MHz\" representing ADS-B frequency. - Additional Info: Raw data (decoded message line). - Latitude/Longitude: Remain as None pending integration of geolocation. Returns: list[dict]: List of dictionaries with ADS-B signal data. Error Handling: All subprocess exceptions are captured, and an empty list is returned in case of failure. Note: An operational RTL-SDR dongle is a prerequisite for this function to yield useful data. \"\"\" try : proc = await asyncio . create_subprocess_exec ( \"dump1090-mutability\" , \"--interactive\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) signals : list [ dict ] = [] start_time = time . time () while time . time () - start_time < COLLECTION_TIMEOUT : line = await proc . stdout . readline () if line : decoded = line . decode () . strip () if decoded . startswith ( \"*\" ): signals . append ({ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"ADS-B\" , \"name_address\" : \"Aircraft\" , \"signal_strength\" : \"N/A\" , \"frequency\" : \"1090 MHz\" , \"additional_info\" : decoded , \"latitude\" : None , \"longitude\" : None }) proc . terminate () return signals except Exception as e : print ( f \"ADS-B error: { str ( e ) } \" ) return []","title":"capture_adsb"},{"location":"collector/#collector.capture_wifi","text":"Perform a Wi-Fi scan by capturing probe requests through tcpdump. The function first determines an active wireless interface: it defaults to \"wlan0\" but will dynamically select another interface that exposes wireless capabilities if needed. It then spawns a subprocess to execute tcpdump with parameters to capture 10 packets (-c 10) in non-parsed format. The scanned output is parsed line-by-line to create a list of dictionaries with: - Timestamp: ISO-formatted time of capture. - Type: \"Wi-Fi\" indicating this scan type. - Name/Address: Descriptive label \"Probe Request\". - Signal Strength: Set as \"N/A\" (placeholder). - Frequency: \"2.4/5 GHz\" indicating the common operating bands. - Additional Info: The raw tcpdump output line. - Latitude/Longitude: Remain None for future enhancement. Returns: Type Description list [ dict ] list[dict]: List of detected Wi-Fi signals as dictionaries. Exception Handling If the subprocess fails or no wireless interface is found, logs the error and returns an empty list. Source code in 3-Feb-Demo/collector.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 async def capture_wifi () -> list [ dict ]: \"\"\" Perform a Wi-Fi scan by capturing probe requests through tcpdump. The function first determines an active wireless interface: it defaults to \"wlan0\" but will dynamically select another interface that exposes wireless capabilities if needed. It then spawns a subprocess to execute tcpdump with parameters to capture 10 packets (-c 10) in non-parsed format. The scanned output is parsed line-by-line to create a list of dictionaries with: - Timestamp: ISO-formatted time of capture. - Type: \"Wi-Fi\" indicating this scan type. - Name/Address: Descriptive label \"Probe Request\". - Signal Strength: Set as \"N/A\" (placeholder). - Frequency: \"2.4/5 GHz\" indicating the common operating bands. - Additional Info: The raw tcpdump output line. - Latitude/Longitude: Remain None for future enhancement. Returns: list[dict]: List of detected Wi-Fi signals as dictionaries. Exception Handling: If the subprocess fails or no wireless interface is found, logs the error and returns an empty list. \"\"\" interface : str = \"wlan0\" try : if not os . path . exists ( f \"/sys/class/net/ { interface } \" ): interfaces = os . listdir ( \"/sys/class/net\" ) interface = next (( i for i in interfaces if os . path . exists ( f \"/sys/class/net/ { i } /wireless\" )), \"eth0\" ) proc = await asyncio . create_subprocess_exec ( \"tcpdump\" , \"-i\" , interface , \"-c\" , \"10\" , \"-nn\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) output , _ = await proc . communicate () return [{ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"Wi-Fi\" , \"name_address\" : \"Probe Request\" , \"signal_strength\" : \"N/A\" , \"frequency\" : \"2.4/5 GHz\" , \"additional_info\" : line . strip (), \"latitude\" : None , \"longitude\" : None } for line in output . decode () . splitlines () if line . strip ()] except Exception as e : print ( f \"Wi-Fi scan error: { str ( e ) } \" ) return []","title":"capture_wifi"},{"location":"collector/#collector.collect_and_send","text":"Main orchestration routine for dynamic hardware detection, signal collection, and communication with the Controller API. Operational Steps Hardware Detection : Checks for the presence of HackRF (for SDR), RTL-SDR dongles (for ADS-B), Bluetooth adapters (via 'hciconfig') and wireless interfaces. The results are compiled into a human-readable device list. Device Registration : Posts the detected devices list to the Controller at the '/api/devices' endpoint. If posting fails, it retries until successful. Signal Collection Loop : Periodically checks the Controller's collection status (via '/api/collection-status'). If active, concurrently dispatches available scan routines (Bluetooth, ADS-B, Wi-Fi). Aggregates all scan results, then sends the collection to the Controller's '/api/collect' endpoint. Waits for SCAN_INTERVAL seconds before starting the next cycle. Exception Handling Individual scan methods handle errors and return empty results on failure. The overall loop logs failures without breaking, ensuring continuous operation. Returns: Name Type Description None None The function perpetually runs in an asynchronous event loop. Design Consideration Uses asyncio.gather to perform scanning concurrently. This design optimizes resource usage while ensuring that hardware detection is adaptive and robust. Source code in 3-Feb-Demo/collector.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 async def collect_and_send () -> None : \"\"\" Main orchestration routine for dynamic hardware detection, signal collection, and communication with the Controller API. Operational Steps: 1. **Hardware Detection**: - Checks for the presence of HackRF (for SDR), RTL-SDR dongles (for ADS-B), Bluetooth adapters (via 'hciconfig') and wireless interfaces. - The results are compiled into a human-readable device list. 2. **Device Registration**: - Posts the detected devices list to the Controller at the '/api/devices' endpoint. - If posting fails, it retries until successful. 3. **Signal Collection Loop**: - Periodically checks the Controller's collection status (via '/api/collection-status'). - If active, concurrently dispatches available scan routines (Bluetooth, ADS-B, Wi-Fi). - Aggregates all scan results, then sends the collection to the Controller's '/api/collect' endpoint. - Waits for SCAN_INTERVAL seconds before starting the next cycle. Exception Handling: - Individual scan methods handle errors and return empty results on failure. - The overall loop logs failures without breaking, ensuring continuous operation. Returns: None: The function perpetually runs in an asynchronous event loop. Design Consideration: - Uses asyncio.gather to perform scanning concurrently. This design optimizes resource usage while ensuring that hardware detection is adaptive and robust. \"\"\" devices_posted : bool = False hackrf_present : bool = False rtlsdr_present : bool = False bt_present : bool = False wifi_ifaces : list [ str ] = [] # Check for HackRF One device (SDR) try : proc = await asyncio . create_subprocess_exec ( \"hackrf_info\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) await proc . communicate () if proc . returncode == 0 : hackrf_present = True except FileNotFoundError : pass # Check for RTL-SDR dongle (required for ADS-B) try : proc = await asyncio . create_subprocess_exec ( \"rtl_test\" , \"-t\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) await proc . communicate () if proc . returncode == 0 : rtlsdr_present = True except FileNotFoundError : pass # Check for Bluetooth adapter via hciconfig output. proc = await asyncio . create_subprocess_exec ( \"hciconfig\" , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) stdout , _ = await proc . communicate () if b \"hci0\" in stdout : bt_present = True # Detect available Wi-Fi interfaces based on the presence of 'wireless' directories. try : wifi_ifaces = [ iface for iface in os . listdir ( \"/sys/class/net\" ) if os . path . exists ( f \"/sys/class/net/ { iface } /wireless\" )] except Exception : wifi_ifaces = [] # Create a descriptive device list. device_list : list [ str ] = [] if hackrf_present : device_list . append ( \"HackRF One\" ) if rtlsdr_present : device_list . append ( \"RTL-SDR dongle\" ) if wifi_ifaces : device_list . append ( f \"Wi-Fi ( { ', ' . join ( wifi_ifaces ) } )\" ) if bt_present : device_list . append ( \"Bluetooth adapter\" ) if not device_list : device_list . append ( \"No RF devices detected\" ) # Register detected devices with the Controller API. try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/devices\" , json = { \"devices\" : device_list }) print ( f \"[Collector] Detected devices: { ', ' . join ( device_list ) } \" ) devices_posted = True except Exception as e : print ( f \"[Collector] Device info post failed: { e } \" ) devices_posted = False # Main asynchronous loop for repetitive scanning and signal reporting. while True : # Retry device registration if necessary. if not devices_posted : try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/devices\" , json = { \"devices\" : device_list }) print ( f \"[Collector] Detected devices: { ', ' . join ( device_list ) } \" ) devices_posted = True except Exception as e : print ( f \"[Collector] Retry device post: { e } \" ) # Proceed with scanning only if collection is enabled by the Controller. if await get_collection_status (): print ( \"[Collector] Starting collection cycle...\" ) tasks : list [ asyncio . Task ] = [] if bt_present : tasks . append ( asyncio . create_task ( scan_bluetooth ())) if rtlsdr_present : tasks . append ( asyncio . create_task ( capture_adsb ())) if wifi_ifaces : tasks . append ( asyncio . create_task ( capture_wifi ())) results = await asyncio . gather ( * tasks ) if tasks else [] all_signals = [ signal for sublist in results for signal in sublist ] # Send aggregated signals to Controller API if any have been collected. if all_signals : try : async with httpx . AsyncClient () as client : await client . post ( f \" { CONTROLLER_URL } /api/collect\" , json = all_signals , timeout = 10 ) print ( f \"[Collector] Sent { len ( all_signals ) } signals\" ) except Exception as e : print ( f \"Failed to send data: { str ( e ) } \" ) else : print ( \"[Collector] No signals collected\" ) # Wait before beginning the next cycle. await asyncio . sleep ( SCAN_INTERVAL )","title":"collect_and_send"},{"location":"collector/#collector.get_collection_status","text":"Retrieve and report whether the centralized Controller has activated data collection. The function makes an asynchronous GET request to the '/api/collection-status' endpoint on the Controller. In the case of errors (e.g., network issues or unexpected responses), it logs the error and returns False, thereby ensuring the collector does not scan unless the controller explicitly indicates active collection. Returns: Name Type Description bool bool True if the Controller API signals that signal collection is active, else False. Design Note This check is performed periodically before each scan cycle to conserve resources. Source code in 3-Feb-Demo/collector.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 async def get_collection_status () -> bool : \"\"\" Retrieve and report whether the centralized Controller has activated data collection. The function makes an asynchronous GET request to the '/api/collection-status' endpoint on the Controller. In the case of errors (e.g., network issues or unexpected responses), it logs the error and returns False, thereby ensuring the collector does not scan unless the controller explicitly indicates active collection. Returns: bool: True if the Controller API signals that signal collection is active, else False. Raises: Exception details are printed to standard output for debugging purposes. Design Note: This check is performed periodically before each scan cycle to conserve resources. \"\"\" try : async with httpx . AsyncClient () as client : response = await client . get ( f \" { CONTROLLER_URL } /api/collection-status\" ) return response . json () . get ( \"active\" , False ) except Exception as e : print ( f \"Error getting collection status: { e } \" ) return False","title":"get_collection_status"},{"location":"collector/#collector.main","text":"Entry point for the Collector service module. Invokes the asynchronous collect_and_send() routine using asyncio.run(), initiating the perpetual scanning loop. Returns: Type Description None None Source code in 3-Feb-Demo/collector.py 334 335 336 337 338 339 340 341 342 343 def main () -> None : \"\"\" Entry point for the Collector service module. Invokes the asynchronous collect_and_send() routine using asyncio.run(), initiating the perpetual scanning loop. Returns: None \"\"\" asyncio . run ( collect_and_send ())","title":"main"},{"location":"collector/#collector.scan_bluetooth","text":"Conduct a Bluetooth Low Energy (BLE) scan for nearby devices using the Bleak library. This function leverages BleakScanner.discover to detect BLE devices for up to COLLECTION_TIMEOUT seconds. For every device found, it returns a dictionary with: - Timestamp: When the device was detected (ISO format). - Type: \"Bluetooth\" (identifies the scan type). - Name/Address: Combines the device name (if available) with its hardware address. - Signal Strength: Hardcoded placeholder (-70 dBm) pending future enhancement. - Frequency: \"2.4 GHz\" to denote typical BLE operation frequency. - Latitude/Longitude: Set as None (reserved for future geo-tagging). Returns: Type Description list [ dict ] list[dict]: A list of dictionaries, each representing an individual BLE device detection. Exception Handling Any scanning error is caught, logged, and the function returns an empty list. Future Enhancement Signal strength measurement may be refined to capture actual RSSI values dynamically. Source code in 3-Feb-Demo/collector.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def scan_bluetooth () -> list [ dict ]: \"\"\" Conduct a Bluetooth Low Energy (BLE) scan for nearby devices using the Bleak library. This function leverages BleakScanner.discover to detect BLE devices for up to COLLECTION_TIMEOUT seconds. For every device found, it returns a dictionary with: - Timestamp: When the device was detected (ISO format). - Type: \"Bluetooth\" (identifies the scan type). - Name/Address: Combines the device name (if available) with its hardware address. - Signal Strength: Hardcoded placeholder (-70 dBm) pending future enhancement. - Frequency: \"2.4 GHz\" to denote typical BLE operation frequency. - Latitude/Longitude: Set as None (reserved for future geo-tagging). Returns: list[dict]: A list of dictionaries, each representing an individual BLE device detection. Exception Handling: Any scanning error is caught, logged, and the function returns an empty list. Future Enhancement: Signal strength measurement may be refined to capture actual RSSI values dynamically. \"\"\" try : devices = await BleakScanner . discover ( timeout = COLLECTION_TIMEOUT ) return [{ \"timestamp\" : datetime . now () . isoformat (), \"type\" : \"Bluetooth\" , \"name_address\" : f \" { d . name or 'Unknown' } [ { d . address } ]\" , \"signal_strength\" : - 70 , \"frequency\" : \"2.4 GHz\" , \"latitude\" : None , \"longitude\" : None } for d in devices ] except Exception as e : print ( f \"Bluetooth scan error: { str ( e ) } \" ) return []","title":"scan_bluetooth"},{"location":"controller/","text":"Controller Documentation Controller Service Module for Project PEAK This module provides a FastAPI-powered web service that centralizes control and data management for the Project PEAK system. It exposes RESTful endpoints for starting/stopping signal collection, updating and retrieving detected hardware details, persisting collected signal data to a SQLite database using SQLAlchemy, and offering a real-time HTML dashboard to monitor and analyze the received signals. Key Features API endpoints for controlling signal collection: /api/start: Enable data collection. /api/stop: Disable data collection. /api/collection-status: Query the current status. Device registration via /api/devices: Allows collectors to report detected hardware. Data ingestion endpoint (/api/collect) for persisting RF signal data with detailed metadata. Endpoints for data retrieval: /api/data: Retrieve all stored signals. /api/save: Export signals as a CSV file. A built-in dashboard (HTML served at '/') that uses Chart.js and Leaflet.js for visualization. Geolocation retrieval for dynamic UI mapping, falling back to default (Denver) if necessary. Usage Execute this module directly (or via Docker) to start the uvicorn ASGI server on port 8000. Requirements Python 3.11+ FastAPI, uvicorn, SQLAlchemy, requests, csv, and other supporting libraries. Author: [Your Name] Date: 2025-04-14 Signal Bases: Base SQLAlchemy ORM model for storing RF signal entries. Attributes: Name Type Description id int Unique primary key. timestamp str Timestamp of signal capture (ISO formatted). type str Signal type (e.g., Bluetooth, ADS-B, Wi-Fi). name_address str Concatenated device name and/or address. signal_strength str Signal strength (may be \"N/A\" if not available). frequency str Reception frequency (e.g., \"1090 MHz\" for ADS-B). latitude float Latitude from geolocation, if available. longitude float Longitude from geolocation, if available. additional_info str Raw or supplementary signal data. Source code in 3-Feb-Demo/controller.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class Signal ( Base ): \"\"\" SQLAlchemy ORM model for storing RF signal entries. Attributes: id (int): Unique primary key. timestamp (str): Timestamp of signal capture (ISO formatted). type (str): Signal type (e.g., Bluetooth, ADS-B, Wi-Fi). name_address (str): Concatenated device name and/or address. signal_strength (str): Signal strength (may be \"N/A\" if not available). frequency (str): Reception frequency (e.g., \"1090 MHz\" for ADS-B). latitude (float): Latitude from geolocation, if available. longitude (float): Longitude from geolocation, if available. additional_info (str): Raw or supplementary signal data. \"\"\" __tablename__ = \"signals\" id = Column ( Integer , primary_key = True , index = True ) timestamp = Column ( String ) type = Column ( String ) name_address = Column ( String ) signal_strength = Column ( String ) frequency = Column ( String ) latitude = Column ( Float ) longitude = Column ( Float ) additional_info = Column ( String ) api_collection_status () async Endpoint: GET /api/collection-status Provides the current state (active/inactive) of the RF signal collection process. Returns: Name Type Description dict dict {\"active\": } indicating if signal collection is enabled. Source code in 3-Feb-Demo/controller.py 126 127 128 129 130 131 132 133 134 135 136 @app . get ( \"/api/collection-status\" ) async def api_collection_status () -> dict : \"\"\" Endpoint: GET /api/collection-status Provides the current state (active/inactive) of the RF signal collection process. Returns: dict: {\"active\": <bool>} indicating if signal collection is enabled. \"\"\" return { \"active\" : collection_active } api_location () async Endpoint: GET /api/location Returns the current geographical coordinates of the Controller. Returns: Name Type Description dict dict A dictionary with keys 'lat' and 'lon' representing the controller's latitude and longitude. Source code in 3-Feb-Demo/controller.py 114 115 116 117 118 119 120 121 122 123 124 @app . get ( \"/api/location\" ) async def api_location () -> dict : \"\"\" Endpoint: GET /api/location Returns the current geographical coordinates of the Controller. Returns: dict: A dictionary with keys 'lat' and 'lon' representing the controller's latitude and longitude. \"\"\" return { \"lat\" : CONTROLLER_LAT , \"lon\" : CONTROLLER_LON } collect_signals ( signals = Body ( ... )) async Endpoint: POST /api/collect Ingests a list of RF signal data dictionaries (sent by collectors), cleans the extra control characters, and persists each entry into the SQLite database using SQLAlchemy. Parameters: Name Type Description Default signals list A list of dictionaries containing signal information (e.g., timestamp, type, name_address, etc.). Body (...) Process Iterates over each dictionary. Removes control characters from the 'additional_info' field for a clean display. Creates and adds a new Signal instance to the database. Commits the changes. Returns: Name Type Description dict dict A confirmation with the count of successfully received signals (e.g., {\"status\": \"success\", \"received\": }). Source code in 3-Feb-Demo/controller.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @app . post ( \"/api/collect\" ) async def collect_signals ( signals : list = Body ( ... )) -> dict : \"\"\" Endpoint: POST /api/collect Ingests a list of RF signal data dictionaries (sent by collectors), cleans the extra control characters, and persists each entry into the SQLite database using SQLAlchemy. Args: signals (list): A list of dictionaries containing signal information (e.g., timestamp, type, name_address, etc.). Process: - Iterates over each dictionary. - Removes control characters from the 'additional_info' field for a clean display. - Creates and adds a new Signal instance to the database. - Commits the changes. Returns: dict: A confirmation with the count of successfully received signals (e.g., {\"status\": \"success\", \"received\": <count>}). \"\"\" db = SessionLocal () control_char_pattern = re . compile ( r '[\\x00-\\x1F\\x7F]' ) for sig in signals : info = sig . get ( \"additional_info\" , \"\" ) cleaned_info = control_char_pattern . sub ( \"\" , info ) new_signal = Signal ( timestamp = sig . get ( \"timestamp\" , \"\" ), type = sig . get ( \"type\" , \"\" ), name_address = sig . get ( \"name_address\" , \"\" ), signal_strength = sig . get ( \"signal_strength\" , \"\" ), frequency = sig . get ( \"frequency\" , \"\" ), latitude = sig . get ( \"latitude\" ), longitude = sig . get ( \"longitude\" ), additional_info = cleaned_info ) db . add ( new_signal ) db . commit () db . close () return { \"status\" : \"success\" , \"received\" : len ( signals )} get_controller_location () Obtain the geolocation coordinates for the Controller using an external service. This function sends a GET request to \"http://ip-api.com/json/\" to retrieve latitude and longitude. If the API call is unsuccessful, it logs the error and falls back to default coordinates (Denver). Returns: Type Description tuple [ float , float ] tuple[float, float]: A tuple containing (latitude, longitude). Notes The geolocation data is used for mapping purposes in the dashboard UI. Source code in 3-Feb-Demo/controller.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_controller_location () -> tuple [ float , float ]: \"\"\" Obtain the geolocation coordinates for the Controller using an external service. This function sends a GET request to \"http://ip-api.com/json/\" to retrieve latitude and longitude. If the API call is unsuccessful, it logs the error and falls back to default coordinates (Denver). Returns: tuple[float, float]: A tuple containing (latitude, longitude). Notes: The geolocation data is used for mapping purposes in the dashboard UI. \"\"\" try : response = requests . get ( \"http://ip-api.com/json/\" ) data = response . json () if data . get ( \"status\" ) == \"success\" : lat = data . get ( \"lat\" ) lon = data . get ( \"lon\" ) print ( f \"[Controller] Detected location: { lat } , { lon } \" ) return lat , lon else : print ( \"[Controller] Geolocation API error; using fallback coordinates.\" ) return 39.7392 , - 104.9903 except Exception as e : print ( f \"[Controller] Exception in geolocation: { e } \" ) return 39.7392 , - 104.9903 get_data () async Endpoint: GET /api/data Retrieves all stored RF signal entries from the database. Returns: Type Description list [ dict ] list[dict]: A list of dictionaries, each representing a stored signal with keys such as timestamp, type, name_address, signal_strength, frequency, latitude, longitude, and additional_info. Source code in 3-Feb-Demo/controller.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 @app . get ( \"/api/data\" ) async def get_data () -> list [ dict ]: \"\"\" Endpoint: GET /api/data Retrieves all stored RF signal entries from the database. Returns: list[dict]: A list of dictionaries, each representing a stored signal with keys such as timestamp, type, name_address, signal_strength, frequency, latitude, longitude, and additional_info. \"\"\" db = SessionLocal () signals = db . query ( Signal ) . all () db . close () return [{ \"timestamp\" : s . timestamp , \"type\" : s . type , \"name_address\" : s . name_address , \"signal_strength\" : s . signal_strength , \"frequency\" : s . frequency , \"latitude\" : s . latitude , \"longitude\" : s . longitude , \"additional_info\" : s . additional_info } for s in signals ] get_devices () async Endpoint: GET /api/devices Returns the most recently recorded list of detected hardware devices. Returns: Name Type Description dict dict A dictionary containing the key 'devices' with an array of device names. Source code in 3-Feb-Demo/controller.py 192 193 194 195 196 197 198 199 200 201 202 @app . get ( \"/api/devices\" ) async def get_devices () -> dict : \"\"\" Endpoint: GET /api/devices Returns the most recently recorded list of detected hardware devices. Returns: dict: A dictionary containing the key 'devices' with an array of device names. \"\"\" return { \"devices\" : devices_info } index () async Serves the dynamic HTML dashboard for monitoring the Project PEAK Controller. Returns: Name Type Description HTMLResponse HTMLResponse The static HTML content rendering the dashboard, featuring control buttons, charts, maps, and data feeds. Source code in 3-Feb-Demo/controller.py 614 615 616 617 618 619 620 621 622 623 @app . get ( \"/\" , response_class = HTMLResponse ) async def index () -> HTMLResponse : \"\"\" Serves the dynamic HTML dashboard for monitoring the Project PEAK Controller. Returns: HTMLResponse: The static HTML content rendering the dashboard, featuring control buttons, charts, maps, and data feeds. \"\"\" return HTML_PAGE reset_data () async Endpoint: POST /api/reset Deletes all RF signal data stored in the database. Side Effects Clears the 'signals' table in the SQLite database. Returns: Name Type Description dict dict A confirmation message indicating that the reset was successful, e.g., {\"status\": \"reset\"}. Source code in 3-Feb-Demo/controller.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 @app . post ( \"/api/reset\" ) async def reset_data () -> dict : \"\"\" Endpoint: POST /api/reset Deletes all RF signal data stored in the database. Side Effects: Clears the 'signals' table in the SQLite database. Returns: dict: A confirmation message indicating that the reset was successful, e.g., {\"status\": \"reset\"}. \"\"\" db = SessionLocal () db . query ( Signal ) . delete () db . commit () db . close () return { \"status\" : \"reset\" } save_data () async Endpoint: POST /api/save Exports the stored RF signal data as a CSV file by reading from the SQLite database and writing data to an in-memory CSV. Process Queries all Signal entries. Writes the data with headers into a CSV format. Wraps the in-memory CSV content into a StreamingResponse with appropriate headers to prompt a file download. Returns: Name Type Description StreamingResponse StreamingResponse A stream of CSV data with the header indicating 'filename=signals_export.csv'. Source code in 3-Feb-Demo/controller.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 @app . post ( \"/api/save\" ) async def save_data () -> StreamingResponse : \"\"\" Endpoint: POST /api/save Exports the stored RF signal data as a CSV file by reading from the SQLite database and writing data to an in-memory CSV. Process: - Queries all Signal entries. - Writes the data with headers into a CSV format. - Wraps the in-memory CSV content into a StreamingResponse with appropriate headers to prompt a file download. Returns: StreamingResponse: A stream of CSV data with the header indicating 'filename=signals_export.csv'. \"\"\" db = SessionLocal () signals = db . query ( Signal ) . all () output = io . StringIO () writer = csv . writer ( output ) writer . writerow ([ \"Timestamp\" , \"Type\" , \"Name/Address\" , \"Signal Strength\" , \"Additional Info\" , \"Frequency\" , \"Latitude\" , \"Longitude\" ]) for s in signals : writer . writerow ([ s . timestamp , s . type , s . name_address , s . signal_strength , s . additional_info , s . frequency , s . latitude , s . longitude ]) db . close () response = StreamingResponse ( io . StringIO ( output . getvalue ()), media_type = \"text/csv\" ) response . headers [ \"Content-Disposition\" ] = \"attachment; filename=signals_export.csv\" return response start_collection () async Endpoint: POST /api/start Activates the RF signal collection process. Side Effects Sets the global variable 'collection_active' to True. Returns: Name Type Description dict dict A confirmation message, e.g., {\"status\": \"collection started\"}. Source code in 3-Feb-Demo/controller.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @app . post ( \"/api/start\" ) async def start_collection () -> dict : \"\"\" Endpoint: POST /api/start Activates the RF signal collection process. Side Effects: Sets the global variable 'collection_active' to True. Returns: dict: A confirmation message, e.g., {\"status\": \"collection started\"}. \"\"\" global collection_active collection_active = True return { \"status\" : \"collection started\" } stop_collection () async Endpoint: POST /api/stop Deactivates the RF signal collection process. Side Effects Sets the global variable 'collection_active' to False. Returns: Name Type Description dict dict A confirmation message, e.g., {\"status\": \"collection stopped\"}. Source code in 3-Feb-Demo/controller.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @app . post ( \"/api/stop\" ) async def stop_collection () -> dict : \"\"\" Endpoint: POST /api/stop Deactivates the RF signal collection process. Side Effects: Sets the global variable 'collection_active' to False. Returns: dict: A confirmation message, e.g., {\"status\": \"collection stopped\"}. \"\"\" global collection_active collection_active = False return { \"status\" : \"collection stopped\" } update_devices ( devices = Body ( ... )) async Endpoint: POST /api/devices Updates the Controller with the latest list of detected hardware devices provided by a collector. Parameters: Name Type Description Default devices dict Expected in the format {\"devices\": [ , , ...]}. Body (...) Side Effects Updates the global 'devices_info' list with the provided devices. Returns: Name Type Description dict dict A simple confirmation message, e.g., {\"status\": \"devices updated\"}. Source code in 3-Feb-Demo/controller.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @app . post ( \"/api/devices\" ) async def update_devices ( devices : dict = Body ( ... )) -> dict : \"\"\" Endpoint: POST /api/devices Updates the Controller with the latest list of detected hardware devices provided by a collector. Args: devices (dict): Expected in the format {\"devices\": [<device1>, <device2>, ...]}. Side Effects: Updates the global 'devices_info' list with the provided devices. Returns: dict: A simple confirmation message, e.g., {\"status\": \"devices updated\"}. \"\"\" global devices_info devices_info = devices . get ( \"devices\" , []) return { \"status\" : \"devices updated\" }","title":"Controller"},{"location":"controller/#controller-documentation","text":"Controller Service Module for Project PEAK This module provides a FastAPI-powered web service that centralizes control and data management for the Project PEAK system. It exposes RESTful endpoints for starting/stopping signal collection, updating and retrieving detected hardware details, persisting collected signal data to a SQLite database using SQLAlchemy, and offering a real-time HTML dashboard to monitor and analyze the received signals. Key Features API endpoints for controlling signal collection: /api/start: Enable data collection. /api/stop: Disable data collection. /api/collection-status: Query the current status. Device registration via /api/devices: Allows collectors to report detected hardware. Data ingestion endpoint (/api/collect) for persisting RF signal data with detailed metadata. Endpoints for data retrieval: /api/data: Retrieve all stored signals. /api/save: Export signals as a CSV file. A built-in dashboard (HTML served at '/') that uses Chart.js and Leaflet.js for visualization. Geolocation retrieval for dynamic UI mapping, falling back to default (Denver) if necessary. Usage Execute this module directly (or via Docker) to start the uvicorn ASGI server on port 8000. Requirements Python 3.11+ FastAPI, uvicorn, SQLAlchemy, requests, csv, and other supporting libraries. Author: [Your Name] Date: 2025-04-14","title":"Controller Documentation"},{"location":"controller/#controller.Signal","text":"Bases: Base SQLAlchemy ORM model for storing RF signal entries. Attributes: Name Type Description id int Unique primary key. timestamp str Timestamp of signal capture (ISO formatted). type str Signal type (e.g., Bluetooth, ADS-B, Wi-Fi). name_address str Concatenated device name and/or address. signal_strength str Signal strength (may be \"N/A\" if not available). frequency str Reception frequency (e.g., \"1090 MHz\" for ADS-B). latitude float Latitude from geolocation, if available. longitude float Longitude from geolocation, if available. additional_info str Raw or supplementary signal data. Source code in 3-Feb-Demo/controller.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class Signal ( Base ): \"\"\" SQLAlchemy ORM model for storing RF signal entries. Attributes: id (int): Unique primary key. timestamp (str): Timestamp of signal capture (ISO formatted). type (str): Signal type (e.g., Bluetooth, ADS-B, Wi-Fi). name_address (str): Concatenated device name and/or address. signal_strength (str): Signal strength (may be \"N/A\" if not available). frequency (str): Reception frequency (e.g., \"1090 MHz\" for ADS-B). latitude (float): Latitude from geolocation, if available. longitude (float): Longitude from geolocation, if available. additional_info (str): Raw or supplementary signal data. \"\"\" __tablename__ = \"signals\" id = Column ( Integer , primary_key = True , index = True ) timestamp = Column ( String ) type = Column ( String ) name_address = Column ( String ) signal_strength = Column ( String ) frequency = Column ( String ) latitude = Column ( Float ) longitude = Column ( Float ) additional_info = Column ( String )","title":"Signal"},{"location":"controller/#controller.api_collection_status","text":"Endpoint: GET /api/collection-status Provides the current state (active/inactive) of the RF signal collection process. Returns: Name Type Description dict dict {\"active\": } indicating if signal collection is enabled. Source code in 3-Feb-Demo/controller.py 126 127 128 129 130 131 132 133 134 135 136 @app . get ( \"/api/collection-status\" ) async def api_collection_status () -> dict : \"\"\" Endpoint: GET /api/collection-status Provides the current state (active/inactive) of the RF signal collection process. Returns: dict: {\"active\": <bool>} indicating if signal collection is enabled. \"\"\" return { \"active\" : collection_active }","title":"api_collection_status"},{"location":"controller/#controller.api_location","text":"Endpoint: GET /api/location Returns the current geographical coordinates of the Controller. Returns: Name Type Description dict dict A dictionary with keys 'lat' and 'lon' representing the controller's latitude and longitude. Source code in 3-Feb-Demo/controller.py 114 115 116 117 118 119 120 121 122 123 124 @app . get ( \"/api/location\" ) async def api_location () -> dict : \"\"\" Endpoint: GET /api/location Returns the current geographical coordinates of the Controller. Returns: dict: A dictionary with keys 'lat' and 'lon' representing the controller's latitude and longitude. \"\"\" return { \"lat\" : CONTROLLER_LAT , \"lon\" : CONTROLLER_LON }","title":"api_location"},{"location":"controller/#controller.collect_signals","text":"Endpoint: POST /api/collect Ingests a list of RF signal data dictionaries (sent by collectors), cleans the extra control characters, and persists each entry into the SQLite database using SQLAlchemy. Parameters: Name Type Description Default signals list A list of dictionaries containing signal information (e.g., timestamp, type, name_address, etc.). Body (...) Process Iterates over each dictionary. Removes control characters from the 'additional_info' field for a clean display. Creates and adds a new Signal instance to the database. Commits the changes. Returns: Name Type Description dict dict A confirmation with the count of successfully received signals (e.g., {\"status\": \"success\", \"received\": }). Source code in 3-Feb-Demo/controller.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @app . post ( \"/api/collect\" ) async def collect_signals ( signals : list = Body ( ... )) -> dict : \"\"\" Endpoint: POST /api/collect Ingests a list of RF signal data dictionaries (sent by collectors), cleans the extra control characters, and persists each entry into the SQLite database using SQLAlchemy. Args: signals (list): A list of dictionaries containing signal information (e.g., timestamp, type, name_address, etc.). Process: - Iterates over each dictionary. - Removes control characters from the 'additional_info' field for a clean display. - Creates and adds a new Signal instance to the database. - Commits the changes. Returns: dict: A confirmation with the count of successfully received signals (e.g., {\"status\": \"success\", \"received\": <count>}). \"\"\" db = SessionLocal () control_char_pattern = re . compile ( r '[\\x00-\\x1F\\x7F]' ) for sig in signals : info = sig . get ( \"additional_info\" , \"\" ) cleaned_info = control_char_pattern . sub ( \"\" , info ) new_signal = Signal ( timestamp = sig . get ( \"timestamp\" , \"\" ), type = sig . get ( \"type\" , \"\" ), name_address = sig . get ( \"name_address\" , \"\" ), signal_strength = sig . get ( \"signal_strength\" , \"\" ), frequency = sig . get ( \"frequency\" , \"\" ), latitude = sig . get ( \"latitude\" ), longitude = sig . get ( \"longitude\" ), additional_info = cleaned_info ) db . add ( new_signal ) db . commit () db . close () return { \"status\" : \"success\" , \"received\" : len ( signals )}","title":"collect_signals"},{"location":"controller/#controller.get_controller_location","text":"Obtain the geolocation coordinates for the Controller using an external service. This function sends a GET request to \"http://ip-api.com/json/\" to retrieve latitude and longitude. If the API call is unsuccessful, it logs the error and falls back to default coordinates (Denver). Returns: Type Description tuple [ float , float ] tuple[float, float]: A tuple containing (latitude, longitude). Notes The geolocation data is used for mapping purposes in the dashboard UI. Source code in 3-Feb-Demo/controller.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def get_controller_location () -> tuple [ float , float ]: \"\"\" Obtain the geolocation coordinates for the Controller using an external service. This function sends a GET request to \"http://ip-api.com/json/\" to retrieve latitude and longitude. If the API call is unsuccessful, it logs the error and falls back to default coordinates (Denver). Returns: tuple[float, float]: A tuple containing (latitude, longitude). Notes: The geolocation data is used for mapping purposes in the dashboard UI. \"\"\" try : response = requests . get ( \"http://ip-api.com/json/\" ) data = response . json () if data . get ( \"status\" ) == \"success\" : lat = data . get ( \"lat\" ) lon = data . get ( \"lon\" ) print ( f \"[Controller] Detected location: { lat } , { lon } \" ) return lat , lon else : print ( \"[Controller] Geolocation API error; using fallback coordinates.\" ) return 39.7392 , - 104.9903 except Exception as e : print ( f \"[Controller] Exception in geolocation: { e } \" ) return 39.7392 , - 104.9903","title":"get_controller_location"},{"location":"controller/#controller.get_data","text":"Endpoint: GET /api/data Retrieves all stored RF signal entries from the database. Returns: Type Description list [ dict ] list[dict]: A list of dictionaries, each representing a stored signal with keys such as timestamp, type, name_address, signal_strength, frequency, latitude, longitude, and additional_info. Source code in 3-Feb-Demo/controller.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 @app . get ( \"/api/data\" ) async def get_data () -> list [ dict ]: \"\"\" Endpoint: GET /api/data Retrieves all stored RF signal entries from the database. Returns: list[dict]: A list of dictionaries, each representing a stored signal with keys such as timestamp, type, name_address, signal_strength, frequency, latitude, longitude, and additional_info. \"\"\" db = SessionLocal () signals = db . query ( Signal ) . all () db . close () return [{ \"timestamp\" : s . timestamp , \"type\" : s . type , \"name_address\" : s . name_address , \"signal_strength\" : s . signal_strength , \"frequency\" : s . frequency , \"latitude\" : s . latitude , \"longitude\" : s . longitude , \"additional_info\" : s . additional_info } for s in signals ]","title":"get_data"},{"location":"controller/#controller.get_devices","text":"Endpoint: GET /api/devices Returns the most recently recorded list of detected hardware devices. Returns: Name Type Description dict dict A dictionary containing the key 'devices' with an array of device names. Source code in 3-Feb-Demo/controller.py 192 193 194 195 196 197 198 199 200 201 202 @app . get ( \"/api/devices\" ) async def get_devices () -> dict : \"\"\" Endpoint: GET /api/devices Returns the most recently recorded list of detected hardware devices. Returns: dict: A dictionary containing the key 'devices' with an array of device names. \"\"\" return { \"devices\" : devices_info }","title":"get_devices"},{"location":"controller/#controller.index","text":"Serves the dynamic HTML dashboard for monitoring the Project PEAK Controller. Returns: Name Type Description HTMLResponse HTMLResponse The static HTML content rendering the dashboard, featuring control buttons, charts, maps, and data feeds. Source code in 3-Feb-Demo/controller.py 614 615 616 617 618 619 620 621 622 623 @app . get ( \"/\" , response_class = HTMLResponse ) async def index () -> HTMLResponse : \"\"\" Serves the dynamic HTML dashboard for monitoring the Project PEAK Controller. Returns: HTMLResponse: The static HTML content rendering the dashboard, featuring control buttons, charts, maps, and data feeds. \"\"\" return HTML_PAGE","title":"index"},{"location":"controller/#controller.reset_data","text":"Endpoint: POST /api/reset Deletes all RF signal data stored in the database. Side Effects Clears the 'signals' table in the SQLite database. Returns: Name Type Description dict dict A confirmation message indicating that the reset was successful, e.g., {\"status\": \"reset\"}. Source code in 3-Feb-Demo/controller.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 @app . post ( \"/api/reset\" ) async def reset_data () -> dict : \"\"\" Endpoint: POST /api/reset Deletes all RF signal data stored in the database. Side Effects: Clears the 'signals' table in the SQLite database. Returns: dict: A confirmation message indicating that the reset was successful, e.g., {\"status\": \"reset\"}. \"\"\" db = SessionLocal () db . query ( Signal ) . delete () db . commit () db . close () return { \"status\" : \"reset\" }","title":"reset_data"},{"location":"controller/#controller.save_data","text":"Endpoint: POST /api/save Exports the stored RF signal data as a CSV file by reading from the SQLite database and writing data to an in-memory CSV. Process Queries all Signal entries. Writes the data with headers into a CSV format. Wraps the in-memory CSV content into a StreamingResponse with appropriate headers to prompt a file download. Returns: Name Type Description StreamingResponse StreamingResponse A stream of CSV data with the header indicating 'filename=signals_export.csv'. Source code in 3-Feb-Demo/controller.py 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 @app . post ( \"/api/save\" ) async def save_data () -> StreamingResponse : \"\"\" Endpoint: POST /api/save Exports the stored RF signal data as a CSV file by reading from the SQLite database and writing data to an in-memory CSV. Process: - Queries all Signal entries. - Writes the data with headers into a CSV format. - Wraps the in-memory CSV content into a StreamingResponse with appropriate headers to prompt a file download. Returns: StreamingResponse: A stream of CSV data with the header indicating 'filename=signals_export.csv'. \"\"\" db = SessionLocal () signals = db . query ( Signal ) . all () output = io . StringIO () writer = csv . writer ( output ) writer . writerow ([ \"Timestamp\" , \"Type\" , \"Name/Address\" , \"Signal Strength\" , \"Additional Info\" , \"Frequency\" , \"Latitude\" , \"Longitude\" ]) for s in signals : writer . writerow ([ s . timestamp , s . type , s . name_address , s . signal_strength , s . additional_info , s . frequency , s . latitude , s . longitude ]) db . close () response = StreamingResponse ( io . StringIO ( output . getvalue ()), media_type = \"text/csv\" ) response . headers [ \"Content-Disposition\" ] = \"attachment; filename=signals_export.csv\" return response","title":"save_data"},{"location":"controller/#controller.start_collection","text":"Endpoint: POST /api/start Activates the RF signal collection process. Side Effects Sets the global variable 'collection_active' to True. Returns: Name Type Description dict dict A confirmation message, e.g., {\"status\": \"collection started\"}. Source code in 3-Feb-Demo/controller.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @app . post ( \"/api/start\" ) async def start_collection () -> dict : \"\"\" Endpoint: POST /api/start Activates the RF signal collection process. Side Effects: Sets the global variable 'collection_active' to True. Returns: dict: A confirmation message, e.g., {\"status\": \"collection started\"}. \"\"\" global collection_active collection_active = True return { \"status\" : \"collection started\" }","title":"start_collection"},{"location":"controller/#controller.stop_collection","text":"Endpoint: POST /api/stop Deactivates the RF signal collection process. Side Effects Sets the global variable 'collection_active' to False. Returns: Name Type Description dict dict A confirmation message, e.g., {\"status\": \"collection stopped\"}. Source code in 3-Feb-Demo/controller.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 @app . post ( \"/api/stop\" ) async def stop_collection () -> dict : \"\"\" Endpoint: POST /api/stop Deactivates the RF signal collection process. Side Effects: Sets the global variable 'collection_active' to False. Returns: dict: A confirmation message, e.g., {\"status\": \"collection stopped\"}. \"\"\" global collection_active collection_active = False return { \"status\" : \"collection stopped\" }","title":"stop_collection"},{"location":"controller/#controller.update_devices","text":"Endpoint: POST /api/devices Updates the Controller with the latest list of detected hardware devices provided by a collector. Parameters: Name Type Description Default devices dict Expected in the format {\"devices\": [ , , ...]}. Body (...) Side Effects Updates the global 'devices_info' list with the provided devices. Returns: Name Type Description dict dict A simple confirmation message, e.g., {\"status\": \"devices updated\"}. Source code in 3-Feb-Demo/controller.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @app . post ( \"/api/devices\" ) async def update_devices ( devices : dict = Body ( ... )) -> dict : \"\"\" Endpoint: POST /api/devices Updates the Controller with the latest list of detected hardware devices provided by a collector. Args: devices (dict): Expected in the format {\"devices\": [<device1>, <device2>, ...]}. Side Effects: Updates the global 'devices_info' list with the provided devices. Returns: dict: A simple confirmation message, e.g., {\"status\": \"devices updated\"}. \"\"\" global devices_info devices_info = devices . get ( \"devices\" , []) return { \"status\" : \"devices updated\" }","title":"update_devices"}]}